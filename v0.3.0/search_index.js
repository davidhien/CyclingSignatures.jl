var documenterSearchIndex = {"docs":
[{"location":"api/#Comparison-Spaces","page":"API","title":"Comparison Spaces","text":"The idea of a comparison space is to have a space Y and a map Gamma rightarrow Y such that the maps\n\nH_1( O_r(gamma) rightarrow Y_r)\n\nyield a meaningful classifier for a cycle in the thickning of gamma. Currently, only static spaces Y are supported.","category":"section"},{"location":"api/#Comparison-Space-Interface","page":"API","title":"Comparison Space Interface","text":"The comparison space interface is defined by:\n\nabstract type AbstractComparisonSpace end\n\nThe following methods are required:\n\nbetti_1(cs): Returns the first Betti number of the comparison space.\nmap_cycle(cs, points, simplices, coeffs): Returns a vector of length betti_1(cs) representing the image of the cycle mapped to the comparison space.","category":"section"},{"location":"api/#Cubical-Comparison-Space","page":"API","title":"Cubical Comparison Space","text":"Cubical comparison spaces are comparison spaces which are cubical complexes.  We implemented cubical comparison spaces in space alone and in the unit tangent bundle. Furthermore, we provide an intereface which can be extended, e.g. to support different domains or periodic boundaries.","category":"section"},{"location":"api/#Interface","page":"API","title":"Interface","text":"The interface for cubical comparison spaces is defined by:\n\nabstract type AbstractCubicalComparisonSpace <: AbstractComparisonSpace end\n\nIt assumes that a cubical acyclic carrier (i.e. a subtype of AbstractCubicalAcyclicCarrier) is used to map the cycle.\n\nThe following methods are required:\n\nedge_boxes(cs, p1, p2): Compute the sequence of boxes covering the edge between points p1 and p2.\ncarrier(cs): Returns the cubical acyclic carrier.\nbetti_1(comparison_space): Returns the first Betti number of the comparison space.\n\nThe implementation of map_cycles for AbstractCubicalComparisonSpaces does the following:\n\nFor each edge:\nCompute the boxes which it intersects (using edge_boxes).\nUse the carrier from carrier(cs) to get a 1-chain in the comparison space.\nSum and return the 1-chains.","category":"section"},{"location":"api/#CubicalComparisonSpace-and-SBCubicalComparisonSpace","page":"API","title":"CubicalComparisonSpace and SBCubicalComparisonSpace","text":"We provide two implementations of cubical comparison spaces:\n\nCubicalComparisonSpace: The cubes are assumed to cover the data in space only.\nSBCubicalComparisonSpace: The cubes are assumed to cover the data in the unit tangent bundle","category":"section"},{"location":"api/#Acyclic-Carrier-Interface","page":"API","title":"Acyclic Carrier Interface","text":"The logic of representing cubical complexes is separated from the logic of the inclusion map. Currently, only a Vietoris–Rips type implementation is supported.","category":"section"},{"location":"api/#Sampleable-Trajectory","page":"API","title":"Sampleable Trajectory","text":"Under Construction.","category":"section"},{"location":"getting-started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"We start with a time series from the Lorenz equations.\n\nusing OrdinaryDiffEq\nusing Plots, StatsPlots\n\nconst σ = 10.0\nconst ρ = 28.0\nconst β = 8/3\n\nfunction lorenz!(du, u, p, t)\n    du[1] = σ * (u[2] - u[1])\n    du[2] = u[1] * (ρ - u[3]) - u[2]\n    du[3] = u[1] * u[2] - β * u[3]\nend\n\nprob = ODEProblem(lorenz!, [1.0, 0.0, 0.0], (0.0, 40.0))\nsol  = solve(prob)\n\nplot(sol, idxs=(1, 2, 3), xlabel=\"x\", ylabel=\"y\", zlabel=\"z\", legend=false)\n\nAlthough we usually recommend it, for this example we do not enforce any condition on the sampling density through the integration.","category":"section"},{"location":"getting-started/#Creating-a-TrajectorySpace","page":"Getting Started","title":"Creating a TrajectorySpace","text":"A TrajectorySpace represents a time series and a cubical cover Y. The cycling signature of a segment is the subspace of H_1(Y) induced by including a thickening of the segment into the Y.\n\nWe generate time series data by evaluating the integrated trajectory on an equidistant grid. We then compute the direction (i.e. normalized tangent vector) at each point.\n\nusing LinearAlgebra\n\ndt = 0.01\ntgrid = 0:dt:40\n\n# time series vector\nX = Array(sol(tgrid))\n\n# compute unit tangent vectors\nTX = mapslices(X, dims=1) do x\n    v = zeros(3)\n    lorenz!(v, x, 0, 0)\n    return normalize(v)\nend\nnothing # hide\n\nWe can construct a TrajectorySpace simply by specifying the time series and two parameters for the size of the boxes used in the cubical cover.  More precisely, the cover uses boxes of size boxsize in space and 1/sb_radius in the unit tangent direction (more precisely, the unit tangent vectors are scaled to sb_radius and then covered with boxes with unit side length).\n\n\nusing CyclingSignatures\n\nx_boxsize = 8.0\nsb_radius = 1\n\ntraj_space = utb_trajectory_space_from_trajectory(X, TX, x_boxsize, sb_radius)","category":"section"},{"location":"getting-started/#Subsegment-Experiments","page":"Getting Started","title":"Subsegment Experiments","text":"We analyze cycling properties for a collection of randomly sampled segments of different lengths. In the following, we select 100 segments of lengths 10:10:500 from the given dataset.\n\n\nsegment_lengths = collect(10:10:500)\nn_runs = 100\nexp = RandomSubsegmentExperiment(traj_space, segment_lengths, n_runs, 42)\n\nresults = run_experiment(exp)\n\nThe resulting collection of cycling signatures can be analyzed to obtain a coarse descrption of the dynamics on the Lorenz attractor.\n\nevaluation_radius = 3.0\n\nplt_rank = plot_rank_distribution_at_r(results, evaluation_radius)\nsig1, plt1 = plot_subspace_frequency_at_r(results, 1, evaluation_radius; n_subspaces=3)\nsig2, plt2 = plot_subspace_frequency_at_r(results, 2, evaluation_radius)\npltinc = plot_cycspace_inclusion(sig1, sig2)\n\ncombined = plot(plt_rank, plt1, plt2, pltinc; size=(800, 600), layout = (2, 2))\n\nThe top left shows the distribution of cycling ranks. While very short segment have rank 0 (which makes sense because they are too short to wrap around anything), after a certain time span all segments have nontrivial cycling rank. Therefore cycling is typical in this time series.\n\nwe see three rank 1 signatures. one much more frequent than\n\nhere: coarse description of the Lorenz system, we see the three oscillations, two wings and transitions, comment that the time series is uneven and that is reflected in the cycling signatures, longer dataset reveals more fine grained information","category":"section"},{"location":"at-tools/#CyclingSignatures.ATTools.AbstractCell","page":"ATTools","title":"CyclingSignatures.ATTools.AbstractCell","text":"The following methods must be implemented:\n\nboundaryOperator\n\n\n\n\n\n","category":"type"},{"location":"at-tools/#CyclingSignatures.ATTools.CoredSparseMatrix","page":"ATTools","title":"CyclingSignatures.ATTools.CoredSparseMatrix","text":"This matrix type assumes that the number of  entries in each row never increases.\n\nBecause of this, we have\n\ngetindex for a row in log(nnz)\ngetindex for a column in #(nnz in column)\n\n\n\n\n\n","category":"type"},{"location":"at-tools/#CyclingSignatures.ATTools.allBoundaryMatrices-Tuple{CyclingSignatures.ATTools.CellComplex}","page":"ATTools","title":"CyclingSignatures.ATTools.allBoundaryMatrices","text":"function allBoundaryMatrices(C::CellComplex)\n\nFirst, computes all boundary matrices. Then, returns them.\n\n\n\n\n\n","category":"method"},{"location":"at-tools/#CyclingSignatures.ATTools.apply!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, CyclingSignatures.ATTools.ColAddOperation{T}}} where T<:Integer","page":"ATTools","title":"CyclingSignatures.ATTools.apply!","text":"function apply!(A::Array{T,2}, addOp::ColAddOperation{T}) where T <: Integer\n\nApplies a ColAddOperation.\n\n\n\n\n\n","category":"method"},{"location":"at-tools/#CyclingSignatures.ATTools.apply!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, CyclingSignatures.ATTools.CoreductionOperation{T}}} where T<:Integer","page":"ATTools","title":"CyclingSignatures.ATTools.apply!","text":"function apply!(A::AbstractArray{T,2}, crOp::CoreductionOperation{T}) where T <: Integer\n\nApplies the coreduction operation. See restore for details.\n\n\n\n\n\n","category":"method"},{"location":"at-tools/#CyclingSignatures.ATTools.basicCoreductions!-Union{Tuple{SparseArrays.AbstractSparseMatrix{T, Int64}}, Tuple{T}, Tuple{SparseArrays.AbstractSparseMatrix{T, Int64}, DataStructures.Stack{CyclingSignatures.ATTools.KernelOperation}}, Tuple{SparseArrays.AbstractSparseMatrix{T, Int64}, DataStructures.Stack{CyclingSignatures.ATTools.KernelOperation}, Vector{Bool}}} where T<:Integer","page":"ATTools","title":"CyclingSignatures.ATTools.basicCoreductions!","text":"function basicReductions!(D1::AbstractSparseMatrix{T,Int}; kernelOperations::Stack{KernelOperation}) where T <: Integer\n\nPerforms basic coreductions, i.e. reductions of rows with up to two entries.\n\n\n\n\n\n","category":"method"},{"location":"at-tools/#CyclingSignatures.ATTools.basicReductions!-Union{Tuple{SparseArrays.AbstractSparseMatrix{T, Int64}}, Tuple{T}, Tuple{SparseArrays.AbstractSparseMatrix{T, Int64}, DataStructures.Stack{CyclingSignatures.ATTools.KernelOperation}}, Tuple{SparseArrays.AbstractSparseMatrix{T, Int64}, DataStructures.Stack{CyclingSignatures.ATTools.KernelOperation}, Vector{Bool}}} where T<:Integer","page":"ATTools","title":"CyclingSignatures.ATTools.basicReductions!","text":"function basicReductions!(D1::AbstractSparseMatrix{T,Int}, kernelOperations::Stack{KernelOperation}=Stack{KernelOperation}, colRemoved::Vector{Bool}=zeros(Bool,size(D1,2))) where T <: Integer\n\nPerforms basic reductions, i.e. reductions of columns with up to two entries.\n\n\n\n\n\n","category":"method"},{"location":"at-tools/#CyclingSignatures.ATTools.boundaryMatrix-Tuple{CyclingSignatures.ATTools.CellComplex, Integer}","page":"ATTools","title":"CyclingSignatures.ATTools.boundaryMatrix","text":"function boundaryMatrix(C::CellComplex, i)\n\nReturns the i-th boundary matrix of the complex C\n\n\n\n\n\n","category":"method"},{"location":"at-tools/#CyclingSignatures.ATTools.boundaryMatrix-Union{Tuple{T}, Tuple{S}, Tuple{Vector{T}, Vector{S}}} where {S<:CyclingSignatures.ATTools.AbstractCell, T<:CyclingSignatures.ATTools.AbstractCell}","page":"ATTools","title":"CyclingSignatures.ATTools.boundaryMatrix","text":"function boundaryMatrix(C1, C2)\n\nGiven a pair of cubical chain groups with bdy(C2) ⊂ C1 this computes the boundary matrix\n\n\n\n\n\n","category":"method"},{"location":"at-tools/#CyclingSignatures.ATTools.circularCoordinates","page":"ATTools","title":"CyclingSignatures.ATTools.circularCoordinates","text":"function circularCoordinates(h, A)\n\nComputes a matrix A such that A[i,:] contains the values of a circle valued function corresponding to the i-th generator of h on the basis of C^0 of h which was used to compute h.D0.\n\n\n\n\n\n","category":"function"},{"location":"at-tools/#CyclingSignatures.ATTools.coboundaryMatrix-Tuple{CyclingSignatures.ATTools.CellComplex, Any}","page":"ATTools","title":"CyclingSignatures.ATTools.coboundaryMatrix","text":"function coboundaryMatrix(C::CellComplex, i)\n\nReturns the i-th coboundary matrix of the complex C\n\n\n\n\n\n","category":"method"},{"location":"at-tools/#CyclingSignatures.ATTools.d1Kernel!-Union{Tuple{AbstractMatrix{T}}, Tuple{T}, Tuple{AbstractMatrix{T}, DataStructures.Stack{CyclingSignatures.ATTools.KernelOperation}}, Tuple{AbstractMatrix{T}, DataStructures.Stack{CyclingSignatures.ATTools.KernelOperation}, Vector{Bool}}} where T<:Integer","page":"ATTools","title":"CyclingSignatures.ATTools.d1Kernel!","text":"function d1Kernel!(A::Array{2,T},kerOp::Stack{KernelOperation}=Stack{KernelOperation}(),colRemoved::Vector{Bool}=zeros(Bool,size(D0,1))) where {T <: Integer}\n\nComputes the kernel using row reduction.\n\n\n\n\n\n","category":"method"},{"location":"at-tools/#CyclingSignatures.ATTools.d1Kernel!-Union{Tuple{SparseArrays.AbstractSparseMatrix{T, Int64}}, Tuple{T}, Tuple{SparseArrays.AbstractSparseMatrix{T, Int64}, DataStructures.Stack{CyclingSignatures.ATTools.KernelOperation}}, Tuple{SparseArrays.AbstractSparseMatrix{T, Int64}, DataStructures.Stack{CyclingSignatures.ATTools.KernelOperation}, Vector{Bool}}} where T<:Integer","page":"ATTools","title":"CyclingSignatures.ATTools.d1Kernel!","text":"function d1Kernel!(D1::AbstractSparseMatrix{T,Int},kerOp::Stack{KernelOperation},preprocess=colRemoved) where {T <: Integer}\n\nComputes the kernel of a 1st boundary matrix.\n\n\n\n\n\n","category":"method"},{"location":"at-tools/#CyclingSignatures.ATTools.findMaxSpanningTree","page":"ATTools","title":"CyclingSignatures.ATTools.findMaxSpanningTree","text":"function findMaxSpanningTree(D0,D1; colRemoved::Vector{Bool}=zeros(Bool,size(D0,1)))\n\nFinds a maximal spanning tree in D0. Edge weight is number of entries in the corresponding column in D1.\n\n\n\n\n\n","category":"function"},{"location":"at-tools/#CyclingSignatures.ATTools.getUnitVectors","page":"ATTools","title":"CyclingSignatures.ATTools.getUnitVectors","text":"function getUnitVectors(indices, m, T=Int)\n\nReturns a sparse (m,lenth(indices))-matrix of type T with i-th column being indices[i]-th standard basis vector.\n\n\n\n\n\n","category":"function"},{"location":"at-tools/#CyclingSignatures.ATTools.liftOfCircleValuedFunction","page":"ATTools","title":"CyclingSignatures.ATTools.liftOfCircleValuedFunction","text":"function liftOfCircleValuedFunction(h::H1, A, LSQR_ATOL = LSQR_TOL, LSQR_RTOL = LSQR_TOL)\n\nComputes a matrix A such that A[i,:] contains the values of a lift of the circle valued function corresponding to the i-th generator of h on the basis of C^0 of h which was used to compute h.D0. This is useful for example to compute the norm of a generator.\n\n\n\n\n\n","category":"function"},{"location":"at-tools/#CyclingSignatures.ATTools.norms","page":"ATTools","title":"CyclingSignatures.ATTools.norms","text":"function norms(h::H1)\n\ncomputes the l2 norms of the generators\n\n\n\n\n\n","category":"function"},{"location":"at-tools/#CyclingSignatures.ATTools.one_skeleton-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any}} where T<:Number","page":"ATTools","title":"CyclingSignatures.ATTools.one_skeleton","text":"function oneSkeleton(D::AbstractArray{T,2}, r) where T <: Number\n\nReturns the 1-skeleton of the VR-complex with distance matrix D. D only need the lower left entries.\n\n\n\n\n\n","category":"method"},{"location":"at-tools/#CyclingSignatures.ATTools.redCored!-Union{Tuple{SparseArrays.AbstractSparseMatrix{T, Int64}}, Tuple{T}, Tuple{SparseArrays.AbstractSparseMatrix{T, Int64}, DataStructures.Stack{CyclingSignatures.ATTools.KernelOperation}}, Tuple{SparseArrays.AbstractSparseMatrix{T, Int64}, DataStructures.Stack{CyclingSignatures.ATTools.KernelOperation}, Vector{Bool}}} where T<:Integer","page":"ATTools","title":"CyclingSignatures.ATTools.redCored!","text":"function redCored!(D1::AbstractSparseMatrix{T,Int}, ) where {T <: Integer}\n\n\n\n\n\n","category":"method"},{"location":"at-tools/#CyclingSignatures.ATTools.removeMaxSpanningTree!-Union{Tuple{T1}, Tuple{T0}, Tuple{SparseArrays.AbstractSparseMatrix{T0, Int64}, SparseArrays.AbstractSparseMatrix{T1, Int64}}, Tuple{SparseArrays.AbstractSparseMatrix{T0, Int64}, SparseArrays.AbstractSparseMatrix{T1, Int64}, Vector{Bool}}} where {T0<:Integer, T1<:Integer}","page":"ATTools","title":"CyclingSignatures.ATTools.removeMaxSpanningTree!","text":"function removeMaxSpanningTree!(D0::AbstractSparseMatrix{T0,Int},D1::AbstractSparseMatrix{T1,Int}; colRemoved::Vector{Bool}=zeros(Bool,size(D0,1))) where {T0 <: Integer, T1 <: Integer}\n\nFinds a maximal spanning tree in the graph defined by D0 with the edges in colRemoved ignored. It then removes the spanning tree by setting the corresponding columns in D1 to zero.\n\n\n\n\n\n","category":"method"},{"location":"at-tools/#CyclingSignatures.ATTools.restore!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, CyclingSignatures.ATTools.ColAddOperation{T}}} where T<:Integer","page":"ATTools","title":"CyclingSignatures.ATTools.restore!","text":"function restore!(A::Array{T,2}, addOp::ColAddOperation{T}) where T <: Integer\n\nRestores a ColAddOperation. Therefore, it is the row(!) operation modeled by the same matrix.\n\n\n\n\n\n","category":"method"},{"location":"at-tools/#CyclingSignatures.ATTools.restore!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, CyclingSignatures.ATTools.CoreductionOperation{T}}} where T<:Integer","page":"ATTools","title":"CyclingSignatures.ATTools.restore!","text":"function restore!(A::Array{T,2}, addOp::ColAddOperation{T}) where T <: Integer\n\nRestores a coreduction two-reduction. Start is      i     j [****|*****|****  ****|*****|****  –- x –- y –-  ****|*****|****  ****|*****|****]\n\nThe reduction had to be performed with discardColValuekeepCol - keepColValueDiscardCol\n\n\n\n\n\n","category":"method"},{"location":"at-tools/#CyclingSignatures.ATTools.restore!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, CyclingSignatures.ATTools.ReductionOperation{T}}} where T<:Integer","page":"ATTools","title":"CyclingSignatures.ATTools.restore!","text":"function restore!(A::Array{T,2}, basicReduction::ReductionOperation{T}) where T <: Integer\n\nRestores the kernel after a basic reduction operation (where a row gets removed).\n\n\n\n\n\n","category":"method"},{"location":"at-tools/#CyclingSignatures.ATTools.vr_incremental-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any, Any}} where T<:Number","page":"ATTools","title":"CyclingSignatures.ATTools.vr_incremental","text":"function vrIncremental(X::AbstractArray{T,2}, d, r; maxdim=size(X,1)) where T <: Number\n\nCompute VR complex for a given point cloud X, distance function d and radius r.\n\n\n\n\n\n","category":"method"},{"location":"at-tools/#CyclingSignatures.ATTools.vr_incremental-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any}} where T<:Number","page":"ATTools","title":"CyclingSignatures.ATTools.vr_incremental","text":"function vrIncremental(D::AbstractArray{T,2}, r; maxdim=size(D,1)) where T <: Number\n\nConstructs the VR-complex from a distance matrix using the incremental construction.\n\n\n\n\n\n","category":"method"},{"location":"#CyclingSignatures.jl","page":"Home","title":"CyclingSignatures.jl","text":"Documentation for CyclingSignatures.jl.","category":"section"},{"location":"#About","page":"Home","title":"About","text":"Cycling signatures are a tool to identify and classify oscillatory dynamics in (multivariate) time series. \n\nGiven a time seris x_0x_1dots x_m in mathbbR^n, the basic pipeline is:\n\nGenerate a comparison space Y by covering the time series and compute its homology H_1(Y).\nCompute the homology H_1(gamma) of thickened segments gamma = x_i x_i+1dots x_j.\nCompute the image of the map H_1(gamma) rightarrow H_1(Y), this is the Cycling Signature.\n\nCollections of cycling signatures can provide a coarse description of recurrent dynamics. For instance, frequently appearing one dimensional cycling signatures indicate elementary cycling motions. These can be related using higher dimensional cycling signatures.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"Install the package by first adding StepFunctions.jl and then CyclingSignatures.jl\n\nusing Pkg\nPkg.add(url=\"https://github.com/davidhien/StepFunctions.jl\")\nPkg.add(url=\"https://github.com/davidhien/CyclingSignatures.jl\")\n\n\nThen load it via\n\nusing CyclingSignatures","category":"section"},{"location":"#References","page":"Home","title":"References","text":"U. Bauer, D. Hien, O. Junge, and K. Mischaikow. Cycling signatures: Identifying cycling motions in time series using algebraic topology. Journal of Computational Dynamics 12(4), 554–595 (2025). DOI: 10.3934/jcd.2025007.","category":"section"},{"location":"cycling-signatures/#CyclingSignatures.curve_cycle-Tuple{Any, Any}","page":"CyclingSignatures","title":"CyclingSignatures.curve_cycle","text":"curve_cycle(i,j;F=DEFAULT_FIELD)\n\nReturns the curve cycle corresponding to i and j where i<j.\n\nReturns\n\nedges: vector of edges [i,i+1], [i+1,i+2], ..., [j-1,j], [i,j].\ncoeffs: coefficients [1,...,1,-1].\n\n\n\n\n\n","category":"method"},{"location":"cycling-signatures/#CyclingSignatures.dm_components_explicit-Tuple{Any, Any, Any}","page":"CyclingSignatures","title":"CyclingSignatures.dm_components_explicit","text":"dm_components_explicit(points, metric, flt_threshold)\n\nComputes a filtration-minimal vertex of each connected component of the distance complex up to the filtration threshold flt_threshold. The distance complex is specified by points and metric.\n\nThis is implmented using a two pass annotation algorithm for images, the image being the upper right part of the distance matrix. In this implementation, the distance matrix is computed explicitly.\n\n\n\n\n\n","category":"method"},{"location":"cycling-signatures/#CyclingSignatures.dm_components_first_pass_explicit-Tuple{Any, Any, Any}","page":"CyclingSignatures","title":"CyclingSignatures.dm_components_first_pass_explicit","text":"dm_components_first_pass_explicit(points, metric, threshold)\n\nGiven a matrix with trajectory points, a metric and a filtrationThreshold, computes the connected components of the graph defined by the matrix pairwise(metric,points) .<= threshold where\n\nvertices are matrix entries,\nedges are nearest 4.\n\nReturns a disjoint set with labels, the label of each entry and the distance matrix. Note: entries with different labels may be in the same component (iff their labels are in the same set in cc)\n\n\n\n\n\n","category":"method"},{"location":"cycling-signatures/#CyclingSignatures.dm_components_first_pass_implicit-Tuple{Any, Any, Any}","page":"CyclingSignatures","title":"CyclingSignatures.dm_components_first_pass_implicit","text":"dm_components_first_pass_explicit(points, metric, threshold)\n\nGiven a matrix with trajectory points, a metric and a filtration threshold, computes the connected components of the graph defined by the matrix pairwise(metric,points) .<= threshold where\n\nvertices are matrix entries,\nedges are nearest 4.\n\nReturns a disjoint set with label and the label of each entry. Note: entries with different labels may be in the same component (iff their labels are in the same set in cc)\n\n\n\n\n\n","category":"method"},{"location":"cycling-signatures/#CyclingSignatures.dm_components_implicit-Tuple{Any, Any, Any}","page":"CyclingSignatures","title":"CyclingSignatures.dm_components_implicit","text":"filtration_min_vertices_implicit_dm(points, metric, flt_threshold)\n\nComputes a filtration-minimal vertex of each connected component of the distance complex specified by points and metric up to the filtration threshold flt_threshold. This is implmented using a two pass annotation algorithm for images, the image being the upper right part of the distance matrix. In this implementation, the distance matrix is not computed explicitly.\n\n\n\n\n\n","category":"method"},{"location":"cycling-signatures/#CyclingSignatures.trajectory_barcode","page":"CyclingSignatures","title":"CyclingSignatures.trajectory_barcode","text":"trajectory_barcode(::Val{:DistanceMatrix}, points, metric, fltThreshold, field=DEFAULT_FIELD)\n\nComputes a trajectory barcode using the distance matrix method, for arguments see trajectory_barcode. This assumes (and formall makes use of) a curve hypothesis.\n\nThe distance complex of a the points in points with respect to the metric is the filtered complex where\n\nvertices are pairs (i, j) with i < j, filtered by metric(points[:, i], points[:, j]) and\nedges are nearest 4, with filtration value of an edge being the max of its adjacent vertices.\n\nNote:\n\nIn general, the returned collection of bars is not a persistence diagram for the point cloud.\n\n\n\n\n\n","category":"function"},{"location":"cycling-signatures/#CyclingSignatures.vertex_to_essential_bar-Tuple{Any, Any, Any}","page":"CyclingSignatures","title":"CyclingSignatures.vertex_to_essential_bar","text":"vertex_to_essential_bar(node, points, metric; field=DEFAULT_FIELD)\n\nGiven a node (i,j) in the distance matrix, returns an essential bar corresponding to the induced cycle in the Vietoris–Rips complex.\n\n\n\n\n\n","category":"method"},{"location":"cycling-signatures/#CyclingSignatures.basic_reduction!-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"CyclingSignatures","title":"CyclingSignatures.basic_reduction!","text":"basic_reduction!(M::AbstractMatrix{T}) where T\n\nPerforms the basic persistence matrix reduction of M in place.\n\n\n\n\n\n","category":"method"},{"location":"cycling-signatures/#CyclingSignatures.colspace_normal_form-Tuple{Any}","page":"CyclingSignatures","title":"CyclingSignatures.colspace_normal_form","text":"colspace_normal_form!(M)\n\nComputes and returns the (nonzero part of the) reduced column echelon form of the matrix M.\n\nElementary column operations are performed to transform M into a form where:\n\nEach pivot value is 1 and is the only non-zero entry in its column.\nThe leading entry of each non-zero column is below the leading entry of the previous row.\ncolumns without leading entries are removed from the matrix.\n\n\n\n\n\n","category":"method"},{"location":"cycling-signatures/#CyclingSignatures.AbstractComparisonSpace","page":"CyclingSignatures","title":"CyclingSignatures.AbstractComparisonSpace","text":"Abstract base type for comparison spaces.\n\nSubtypes must implement:\n\nmap_cycle(cs, points, simplices, coeffs): Maps a cycle into the comparison space\nbetti_1(cs)\n\n\n\n\n\n","category":"type"},{"location":"cycling-signatures/#CyclingSignatures.AbstractCubicalAcyclicCarrier","page":"CyclingSignatures","title":"CyclingSignatures.AbstractCubicalAcyclicCarrier","text":"Abstract base type for cubical acyclic carriers. Subtypes represent an implementation of a cell complex representing a union of cubes which allows the construction of chains from acyclic subsets and the annotation of cycles using a cohomology basis.\n\nSubtypes must implement:\n\ninduced_one_chain(carrier, edge_boxes): Given a vector of boxes covering an edge, computes the induced one-chain.\nannotate_chain(carrier, chain): Annotates a chain using a cohomology basis. For cycles, the result is independent of the representative.\nbetti_1(carrier): Returns the first betti number of the carrier.\n\n\n\n\n\n","category":"type"},{"location":"cycling-signatures/#CyclingSignatures.AbstractCubicalComparisonSpace","page":"CyclingSignatures","title":"CyclingSignatures.AbstractCubicalComparisonSpace","text":"Abstract type for cubical-based comparison spaces. Inherits from AbstractComparisonSpace.\n\nSubtypes must implement:\n\nedge_boxes(comparison_space, p1, p2): Computes the boxes covering the edge between points p1 and p2.\ncarrier(comparison_space): Returns an associated cubical acyclic carrier.\nbetti_1(comparison_space): Returns the first betti number of the comparison space.\n\n\n\n\n\n","category":"type"},{"location":"cycling-signatures/#CyclingSignatures.AbstractSampleableTrajectory","page":"CyclingSignatures","title":"CyclingSignatures.AbstractSampleableTrajectory","text":"Abstract base type for trajectories that can be used in cycling computations.\n\nSubtypes must implement:\n\nevaluate_interval(trajectory, a, b): Returns points that the trajectory visits between time a and b.\ntime_domain(trajectory): Returns time domain of the trajectory\n\n\n\n\n\n","category":"type"},{"location":"cycling-signatures/#CyclingSignatures.CubicalComparisonSpace","page":"CyclingSignatures","title":"CyclingSignatures.CubicalComparisonSpace","text":"Standard cubical comparison space.\n\nFields\n\nboxsize::T: Size of cubical boxes\ncarrier::C: Associated cubical acyclic carrier\n\n\n\n\n\n","category":"type"},{"location":"cycling-signatures/#CyclingSignatures.CubicalVRCarrier","page":"CyclingSignatures","title":"CyclingSignatures.CubicalVRCarrier","text":"Fields\n\npts::Matrix{S}: Points in the carrier, where S is an integer type. The columns are assumed to be sorted.\ncplx::CellComplex{Simplex}: The Nerve of the cubical cover, it is the l_infty-distance VR-complex of the box centers.\nh1::V: The transpose of h1 is a basis for the first cohomology of the complex.\n\n\n\n\n\n","category":"type"},{"location":"cycling-signatures/#CyclingSignatures.CubicalVRCarrier-Union{Tuple{AbstractMatrix{S}}, Tuple{S}} where S<:Integer","page":"CyclingSignatures","title":"CyclingSignatures.CubicalVRCarrier","text":"CubicalVRCarrier(pts::Matrix{S}) where S\n\nTODO: write docstring\n\n\n\n\n\n","category":"method"},{"location":"cycling-signatures/#CyclingSignatures.DynamicDistance","page":"CyclingSignatures","title":"CyclingSignatures.DynamicDistance","text":"DynamicDistance{C} <: Metric\n\nCalculates the distance between points in the tangent bundle according to the formula\n\nd_dyn((pv)(qw)) = max(p - q C v - w)\n\nwhere C is a constant.\n\nFields\n\ndim::Int: The dimension of the space (i.e. half the tangent space dimension).\nc::C: The constant used in the distance calculation.\n\n\n\n\n\n","category":"type"},{"location":"cycling-signatures/#CyclingSignatures.FF","page":"CyclingSignatures","title":"CyclingSignatures.FF","text":"FF{M} <: Integer\n\nFF{M} is the default field used in CyclingSignatures. It is a representation of a finite field mathbbZ_M, integers modulo small, prime M. Supports field arithmetic and can be converted to integer with Int.\n\nExample\n\njulia> FF{3}(5)\n2 mod 3\n\njulia> FF{3}(5) + 1\n0 mod 3\n\nCopyright\n\nCopyright (c) 2020 mtsch\n\n\n\n\n\n","category":"type"},{"location":"cycling-signatures/#CyclingSignatures.RefinedEquidistantTrajectory","page":"CyclingSignatures","title":"CyclingSignatures.RefinedEquidistantTrajectory","text":"struct RefinedEquidistantTrajectory\n\nModels a refinement of a trajectory on an equidistant grid.\n\nMore precisely, the points [trajectory[:, i] for i in t_vec[1:end-1]] are assumed to be the sample points, and the other points are the refined points.\n\nIt holds for all i in 1:length(t_vec)-1 that the points in the i-th interval are given by the indices in t_vec[i]:t_vec[i+1]-1.\n\n\n\n\n\n","category":"type"},{"location":"cycling-signatures/#CyclingSignatures.SBCubicalComparisonSpace","page":"CyclingSignatures","title":"CyclingSignatures.SBCubicalComparisonSpace","text":"Sphere bundle cubical comparison space.\n\nFields\n\nboxsize::T: Size of cubical boxes\nsb_radius::TT: Sub-block radius parameter\ncarrier::C: Associated cubical acyclic carrier\n\n\n\n\n\n","category":"type"},{"location":"cycling-signatures/#CyclingSignatures.betti_1-Tuple{AbstractComparisonSpace}","page":"CyclingSignatures","title":"CyclingSignatures.betti_1","text":"betti_1(cs::AbstractComparisonSpace)\n\nReturns the first betti number of the comparison space.\n\n\n\n\n\n","category":"method"},{"location":"cycling-signatures/#CyclingSignatures.betti_1-Tuple{AbstractCubicalAcyclicCarrier}","page":"CyclingSignatures","title":"CyclingSignatures.betti_1","text":"betti_1(carrier)\n\nReturns the first betti number of the carrier.\n\n\n\n\n\n","category":"method"},{"location":"cycling-signatures/#CyclingSignatures.boxes_bfs_shortest_path-Tuple{Any, Any, Any}","page":"CyclingSignatures","title":"CyclingSignatures.boxes_bfs_shortest_path","text":"grid_bfs_shortest_path(points, p1, p2)\n\nGiven a sorted matrix of points points on an integer grid and two points p1 and p2, finds a shortest path between them using BFS.\n\n\n\n\n\n","category":"method"},{"location":"cycling-signatures/#CyclingSignatures.cycling_signature","page":"CyclingSignatures","title":"CyclingSignatures.cycling_signature","text":"cycling_signature([alg::Val, ]trajectory_space::TrajectorySpace, range; r_max, field=DEFAULT_FIELD)\n\nComputes the cycling signature of the segment specified by range inside of trajectory_space for filtration values 0r_max. Optionally, a field and an algorithm can be specified.\n\nArguments\n\nalg: currently only :DistanceMatrix works\ntrajectory_space: the trajectory space\nrange: currently, this evaluates the cycling signature on the interval [first(range):last(range)]\nr_max: if unspecified, the default in trajectory_space is used\nfield: coefficient field for homology computation\n\nReturns\n\nTODO\n\n\n\n\n\n","category":"function"},{"location":"cycling-signatures/#CyclingSignatures.cycspace_inclusion_matrix-Tuple{Any, Any}","page":"CyclingSignatures","title":"CyclingSignatures.cycspace_inclusion_matrix","text":"cycspace_inclusion_matrix(V, W)\n\nFor a list of matrices V and W, compute the inclusion matrix where entry (i,j) is 1 if the image of V[i] is included in the image of W[j], and 0 otherwise.\n\n\n\n\n\n","category":"method"},{"location":"cycling-signatures/#CyclingSignatures.cycspace_segments-Tuple{RandomSubsegmentResult, Any}","page":"CyclingSignatures","title":"CyclingSignatures.cycspace_segments","text":"cycspace_segments(result::RandomSubsegmentResult, V)\n\nGet the segments from the result that generate the cycling space V for some radius.\n\n\n\n\n\n","category":"method"},{"location":"cycling-signatures/#CyclingSignatures.cycspace_segments_at_r-Tuple{RandomSubsegmentResult, Any, Any}","page":"CyclingSignatures","title":"CyclingSignatures.cycspace_segments_at_r","text":"cycspace_segments_at_r(result::RandomSubsegmentResult, V, r)\n\nGet the segments from the result have cycling space V at radius r.\n\n\n\n\n\n","category":"method"},{"location":"cycling-signatures/#CyclingSignatures.dynamicIndices-Tuple{Matrix}","page":"CyclingSignatures","title":"CyclingSignatures.dynamicIndices","text":"function dynamicIndices(dataq::Matrix)\n\nReturns a vector v and a matrix M s.t. the columns of M are pairwise distinct and M[:,v[t]] = dataq[:,t] for all t. In other words, M contains the unique boxes and v[t] the index of the box at time step t.\n\n\n\n\n\n","category":"method"},{"location":"cycling-signatures/#CyclingSignatures.edge_boxes-Tuple{Any, Any}","page":"CyclingSignatures","title":"CyclingSignatures.edge_boxes","text":"edge_boxes(p1, p2)\n\nComputes the centers of all integer grid boxes which intersect the edge [p1;p2].\n\n\n\n\n\n","category":"method"},{"location":"cycling-signatures/#CyclingSignatures.fix_edge-Tuple{CyclingSignatures.CubicalVRCarrier, Any, Any}","page":"CyclingSignatures","title":"CyclingSignatures.fix_edge","text":"fix_edge(carrier::CubicalVRCarrier, box1, box2)\n\nSearches for a (short) shortest path between the boxes. Note that current implementation is not well-defined since it may be random which way a missing box is bypassed.\n\n\n\n\n\n","category":"method"},{"location":"cycling-signatures/#CyclingSignatures.induced_one_chain-Tuple{AbstractCubicalAcyclicCarrier, Any}","page":"CyclingSignatures","title":"CyclingSignatures.induced_one_chain","text":"induced_one_chain(carrier::AbstractCubicalAcyclicCarrier, edge_boxes)\n\nImplements the conversion of an acyclic cubical cover to an induced chain.\n\nArguments\n\ncarrier::AbstractCubicalAcyclicCarrier: The cubical acyclcic carrier\nedge_boxes: Boxes that cover an one chain\n\nReturns\n\nA representation of an induced chain\n\n\n\n\n\n","category":"method"},{"location":"cycling-signatures/#CyclingSignatures.intersect_lines-Tuple{Any, Any}","page":"CyclingSignatures","title":"CyclingSignatures.intersect_lines","text":"intersect_lines(a,b)\n\nComputes the intersection of the lines (1-l)*a[i]+l*b[i]\n\n\n\n\n\n","category":"method"},{"location":"cycling-signatures/#CyclingSignatures.lenght_countdict_to_countmatrix-Tuple{Any}","page":"CyclingSignatures","title":"CyclingSignatures.lenght_countdict_to_countmatrix","text":"lenght_countdict_to_countmatrix(ct_dict; n_relevant = nothing)\n\nConvert a length count dictionary (i.e. key maps to a vector of counts per segment length) to a count matrix for the n_relevant most appearing keys.\n\n\n\n\n\n","category":"method"},{"location":"cycling-signatures/#CyclingSignatures.map_cycle-Tuple{AbstractComparisonSpace, Any, Any, Any}","page":"CyclingSignatures","title":"CyclingSignatures.map_cycle","text":"map_cycle(cs::AbstractComparisonSpace, points, simplices, coeffs)\n\nAnnotates the cycle specified by points, simplices and coeffs into a comparison space using the given comparison space.\n\nArguments\n\ncs::AbstractComparisonSpace: The comparison space\npoints: Points defining the cycle\nsimplices: Simplices in the cycle\ncoeffs: Coefficients for the cycle\n\nReturns\n\nMapped cycle representation (implementation-dependent)\n\n\n\n\n\n","category":"method"},{"location":"cycling-signatures/#CyclingSignatures.mod_prime-Union{Tuple{M}, Tuple{Any, Val{M}}} where M","page":"CyclingSignatures","title":"CyclingSignatures.mod_prime","text":"mod_prime(i, ::Val{M})\n\nLike mod, but with prime M.\n\n\n\n\n\n","category":"method"},{"location":"cycling-signatures/#CyclingSignatures.projection_max_switches-Tuple{Any, Any}","page":"CyclingSignatures","title":"CyclingSignatures.projection_max_switches","text":"projection_max_switches(v1, v2)\n\nComputes a vector of times T which partition the interval [0,1] such that λ \\mapsto (1-λ)v_1 + λ v_2 has the same maximal component in each interval [T[0];T[1]].\n\n\n\n\n\n","category":"method"},{"location":"cycling-signatures/#CyclingSignatures.quantize-Tuple{Any, Any}","page":"CyclingSignatures","title":"CyclingSignatures.quantize","text":"quantizes each column of x to a grid of size r.\n\nIf r is an integer, boxes have size r in each dimension, if r is a vector, it has to contain a length for every dimension.\n\n\n\n\n\n","category":"method"},{"location":"cycling-signatures/#CyclingSignatures.quantize_subset-NTuple{4, Any}","page":"CyclingSignatures","title":"CyclingSignatures.quantize_subset","text":"Quantizes with s giving the box size per dimension, then maps points outside [q_min,q-max] to nearest box\n\n\n\n\n\n","category":"method"},{"location":"cycling-signatures/#CyclingSignatures.rank_distribution-Tuple{RandomSubsegmentResult, Any}","page":"CyclingSignatures","title":"CyclingSignatures.rank_distribution","text":"rank_distribution(result::RandomSubsegmentResult, k)\n\nCompute the rank distribution for dimension k from the given RandomSubsegmentResult.\n\n\n\n\n\n","category":"method"},{"location":"cycling-signatures/#CyclingSignatures.resampleToConsistent-NTuple{4, Any}","page":"CyclingSignatures","title":"CyclingSignatures.resampleToConsistent","text":"function resampleToConsistent(ds, Y, r, dt)\n\nAdds additional sample points to a time series Y from a dynamical system ds at time step dt such that the resulting time series quantized at r is consistent.\n\nInstead of the actual trajectory points, one can also make pp(Y) dynamically consistent, where pp is a postprocessing applied to the data (for example a rescaling).\n\nFurthermore, it is possible to specify a sbradius and a sbfct which ensures consistency in the sphere bundle. Note: this works as follows: the output of the integrator is applied to sbfct, this will be scaled to sbRadius (in lInf norm) and then checked for consistency\n\n\n\n\n\n","category":"method"},{"location":"cycling-signatures/#CyclingSignatures.resampleToConsistent-NTuple{5, Any}","page":"CyclingSignatures","title":"CyclingSignatures.resampleToConsistent","text":"function resampleToConsistent(ds, ic, ec, r, dt; pp=identity, verbose=false, max_depth=16)\n\nReturns a matrix M such that [M ec] is dynamically consistent and M[:,1] = ic. Note that M[:,end] != ec.\n\n\n\n\n\n","category":"method"},{"location":"cycling-signatures/#CyclingSignatures.resampleToDistance","page":"CyclingSignatures","title":"CyclingSignatures.resampleToDistance","text":"function resampleToDistance(ds, Y, r, dt; kwargs...)\n\nAdds additional sample points to a time series Y from a dynamical system ds at time step dt such that the resulting time series satisfies the specified distance requirements\n\nInstead of the actual trajectory points, one can also require pp(Y) to satisfy the requirement, where pp is a postprocessing applied to the data (for example a rescaling).\n\nFurthermore, it is possible to specify a sbradius and a sbfct which ensures consistency in the sphere bundle. Note: this works as follows: the output of the integrator is applied to sbfct, this will be scaled to sbRadius (in lInf norm) and then checked for consistency\n\n\n\n\n\n","category":"function"}]
}
